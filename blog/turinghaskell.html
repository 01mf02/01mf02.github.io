<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Running Turing machines in Haskell - gedenkt.at</title>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../"><img src="../media/gedenkt_small.png" /></a>
            </div>
            <div id="navigation">
                <a href="../">Initium</a>
                <a href="../erasmus.html">Erasmus</a>
                <a href="../musica.html">Musica</a>
                <a href="../blog.html">Blog</a>
            </div>
        </div>

        <div id="content">
            <h1>Running Turing machines in Haskell</h1>

            <div class="info">
    Geschrieben am 10. Jänner 2015
    
</div>

<p>Creating a Turing machine simulator qualifies as a “been there, done that” project. So I set out to create my own simulator in Haskell, trying to see how simple I could make it.</p>
<h2 id="turing-machine-description">Turing machine description</h2>
<p>Let us shortly recall what a Turing machine is. A Turing machine consists of:</p>
<ul>
<li>A tape, which stores a sequence of symbols.</li>
<li>A tape head, which can be read and write symbols on the tape.</li>
<li>A finite set of states, among which there is a unique starting, accepting and rejecting state.</li>
<li>A transition function δ.</li>
</ul>
<p>(This is only one possible way to describe a Turing machine. There are approximately a gazillion other approaches.)</p>
<p>The purpose of a Turing machine is to determine for a given input word whether it accepts or rejects this word. To do so, at first the input word is written to the tape, the tape head is placed on the first symbol of the input word, and the machine’s current state is set to its starting state. In each state, the machine does the following:</p>
<ol style="list-style-type: decimal">
<li>Read the symbol on the tape under the tape head.</li>
<li>Replace tape symbol by a new symbol.</li>
<li>Move tape head by one position left or right.</li>
<li>Set the machine’s current state to a new state.</li>
</ol>
<p>More formally, the exact behaviour of the machine in each state is determined by the machine’s transition function δ(s, c) = (s’, c’, d): When the machine is in the state s and it reads the symbol c from the tape head, it will overwrite the symbol c under the tape head with c’, move the tape head in the direction determined by d ∈ {→, ←}, and it will finally set its new state to s’.</p>
<p>As soon as the machine reaches its accepting or rejecting state, it halts — the word is accepted respectively rejected. It can also be the case that the machine will never reach an accepting or rejecting state, in which case the machine will run forever (or at least as long as nobody pulls the plug) — it does not terminate.</p>
<p>Let us pay some attention to the tape: The tape has finite length, namely at first the length of the input word. However, when the tape head goes beyond the tape (either to the left or to the right), the tape gets automatically extended by one, and the tape head reads a blank symbol. That way, the Turing machine can allocate a principally infinite amount of memory on the tape.</p>
<h2 id="haskell">Haskell</h2>
<p>The implementation of the Turing machine as described above turned out to be relatively easy. The most complicated part turned out to be how to represent the tape and the tape head efficiently: I represent these by the sequence of symbols on the tape to the left of the tape head, the symbol under the tape head, and finally the sequence of symbols to the right of the tape head. One could represent these sequences by Haskell lists, but consider that when the tape head moves left, we have to obtain the rightmost (i.e. last) symbol from the tape part to the left of the the tape head position, and obtaining the last element of a list in Haskell is slow. For this reason, I chose Haskell’s Sequence datatype, which, among other nice features, allows constant-time retrieval of the last sequence element. Here I’d like to quote Dan Burton, who called Haskell’s sequences <a href="http://stackoverflow.com/a/9613203">“functional awesomesauce”</a>.</p>
<p>Now, without further ado, here is the code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Turing</span> <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Data.Foldable</span> (toList)
<span class="kw">import qualified</span> <span class="dt">Data.List</span> <span class="kw">as</span> <span class="dt">L</span>
<span class="kw">import qualified</span> <span class="dt">Data.Sequence</span> <span class="kw">as</span> <span class="dt">Seq</span>
<span class="kw">import           </span><span class="dt">Data.Sequence</span> (<span class="dt">Seq</span>, (&lt;|), (|&gt;), <span class="dt">ViewL</span> (..), <span class="dt">ViewR</span>(..))

<span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">Symbol</span> <span class="fu">=</span> <span class="dt">Char</span>

<span class="co">-- | Tape head movement direction.</span>
<span class="kw">data</span> <span class="dt">Direction</span> <span class="fu">=</span> <span class="dt">MoveLeft</span> <span class="fu">|</span> <span class="dt">MoveRight</span>

<span class="kw">data</span> <span class="dt">Machine</span> <span class="fu">=</span> <span class="dt">Machine</span> {
  <span class="co">-- | @'transition' s smb@ defines the behaviour of the machine when it</span>
  <span class="co">-- is in state @s@ and @smb@ is the symbol under the tape head.</span>
  <span class="co">-- The function returns the next state of the machine,</span>
  <span class="co">-- the symbol overwriting the current symbol under the tape head,</span>
  <span class="co">-- and the direction in which the tape head should move after overwriting.</span>
  <span class="fu">--</span>
  <span class="co">-- If @smb@ is @'Just' x@, that signifies that @x@ is the current symbol</span>
  <span class="co">-- under the tape head.</span>
  <span class="co">-- If @smb@ is 'Nothing', that means that the tape head is over a</span>
  <span class="co">-- tape position that has not been initialised yet.</span>
<span class="ot">  transition ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> (<span class="dt">State</span>, <span class="dt">Symbol</span>, <span class="dt">Direction</span>)

, startState, acceptState,<span class="ot"> rejectState ::</span> <span class="dt">State</span>
}

<span class="kw">data</span> <span class="dt">TapeCfg</span> <span class="fu">=</span> <span class="dt">TapeCfg</span> {
<span class="ot">  leftSyms  ::</span> <span class="dt">Seq</span> <span class="dt">Symbol</span>    <span class="co">-- ^ symbols to the left of tape head</span>
,<span class="ot"> currSym   ::</span> <span class="dt">Maybe</span> <span class="dt">Symbol</span>  <span class="co">-- ^ symbol under the tape head</span>
,<span class="ot"> rightSyms ::</span> <span class="dt">Seq</span> <span class="dt">Symbol</span>    <span class="co">-- ^ symbols to the right of tape head</span>
}

<span class="kw">data</span> <span class="dt">MachineCfg</span> <span class="fu">=</span> <span class="dt">MachineCfg</span> {
<span class="ot">  currState ::</span> <span class="dt">State</span>
,<span class="ot"> tapeCfg ::</span> <span class="dt">TapeCfg</span>
}

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">TapeCfg</span> <span class="kw">where</span>
  show (<span class="dt">TapeCfg</span> l c r) <span class="fu">=</span> toList l <span class="fu">++</span> [maybe <span class="ch">' '</span> id c] <span class="fu">++</span> toList r

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">MachineCfg</span> <span class="kw">where</span>
  show (<span class="dt">MachineCfg</span> s t) <span class="fu">=</span>
    show t <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span> replicate (Seq.length <span class="fu">$</span> leftSyms t) <span class="ch">' '</span> <span class="fu">++</span> <span class="st">&quot;| q&quot;</span> <span class="fu">++</span> show s
  showList <span class="fu">=</span> showString <span class="fu">.</span> L.intercalate <span class="st">&quot;\n\n&quot;</span> <span class="fu">.</span> map show

<span class="co">-- | Replace symbol under tape head with new symbol, then move tape head.</span>
<span class="ot">updateTapeCfg ::</span> <span class="dt">TapeCfg</span> <span class="ot">-&gt;</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Direction</span> <span class="ot">-&gt;</span> <span class="dt">TapeCfg</span>
updateTapeCfg (<span class="dt">TapeCfg</span> lSyms _ rSyms) newSym <span class="dt">MoveLeft</span> <span class="fu">=</span>
  <span class="kw">case</span> Seq.viewr lSyms <span class="kw">of</span> <span class="dt">EmptyR</span> <span class="ot">-&gt;</span> <span class="dt">TapeCfg</span> Seq.empty <span class="dt">Nothing</span> right
                          lInit <span class="fu">:&gt;</span> lLast <span class="ot">-&gt;</span> <span class="dt">TapeCfg</span> lInit (<span class="dt">Just</span> lLast) right
  <span class="kw">where</span> right <span class="fu">=</span> newSym <span class="fu">&lt;|</span> rSyms
updateTapeCfg (<span class="dt">TapeCfg</span> lSyms _ rSyms) newSym <span class="dt">MoveRight</span> <span class="fu">=</span>
  <span class="kw">case</span> Seq.viewl rSyms <span class="kw">of</span> <span class="dt">EmptyL</span> <span class="ot">-&gt;</span> <span class="dt">TapeCfg</span> left <span class="dt">Nothing</span> Seq.empty
                          rHead <span class="fu">:&lt;</span> rTail <span class="ot">-&gt;</span> <span class="dt">TapeCfg</span> left (<span class="dt">Just</span> rHead) rTail
  <span class="kw">where</span> left <span class="fu">=</span> lSyms <span class="fu">|&gt;</span> newSym

<span class="co">-- | Execute one transition step for given machine and config.</span>
<span class="ot">updateMachineCfg ::</span> <span class="dt">Machine</span> <span class="ot">-&gt;</span> <span class="dt">MachineCfg</span> <span class="ot">-&gt;</span> <span class="dt">MachineCfg</span>
updateMachineCfg m (<span class="dt">MachineCfg</span> state tape) <span class="fu">=</span>
  <span class="kw">let</span> (state', newSym, dir) <span class="fu">=</span> transition m state (currSym tape)
  <span class="kw">in</span> <span class="dt">MachineCfg</span> state' <span class="fu">$</span> updateTapeCfg tape newSym dir

<span class="co">-- | Initialise tape with input word.</span>
<span class="ot">initTapeCfg ::</span> [<span class="dt">Symbol</span>] <span class="ot">-&gt;</span> <span class="dt">TapeCfg</span>
initTapeCfg [] <span class="fu">=</span> <span class="dt">TapeCfg</span> Seq.empty <span class="dt">Nothing</span> Seq.empty
initTapeCfg (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">TapeCfg</span> Seq.empty (<span class="dt">Just</span> x) (Seq.fromList xs)

<span class="co">-- | Initialise machine config with input word.</span>
<span class="ot">initMachineCfg ::</span> <span class="dt">Machine</span> <span class="ot">-&gt;</span> [<span class="dt">Symbol</span>] <span class="ot">-&gt;</span> <span class="dt">MachineCfg</span>
initMachineCfg m input <span class="fu">=</span> <span class="dt">MachineCfg</span> (startState m) (initTapeCfg input)

<span class="co">-- | Return true if the machine is in a final state.</span>
<span class="ot">machineCfgFinal ::</span> <span class="dt">Machine</span> <span class="ot">-&gt;</span> <span class="dt">MachineCfg</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
machineCfgFinal m (<span class="dt">MachineCfg</span> {currState <span class="fu">=</span> c}) <span class="fu">=</span>
  c <span class="fu">==</span> acceptState m <span class="fu">||</span>
  c <span class="fu">==</span> rejectState m

<span class="co">-- | Return sequence of machine configs for given input word until final state.</span>
<span class="ot">runMachine ::</span> <span class="dt">Machine</span> <span class="ot">-&gt;</span> [<span class="dt">Symbol</span>] <span class="ot">-&gt;</span> [<span class="dt">MachineCfg</span>]
runMachine m <span class="fu">=</span>
  break' (machineCfgFinal m) <span class="fu">.</span> iterate (updateMachineCfg m) <span class="fu">.</span> initMachineCfg m
  <span class="kw">where</span>
    <span class="co">-- | Like 'break', but also return first element that fulfills condition</span>
    break' p xs <span class="fu">=</span> <span class="kw">let</span> (prefix, rest) <span class="fu">=</span> break p xs <span class="kw">in</span> prefix <span class="fu">++</span> [head rest]</code></pre>
<p>Now we would like to test this code on an example machine. For this, I made a very simple Turing machine: It starts in state 0 and will move to the right as long as it reads any symbol (<code>Just x</code> in the code below) on the tape. As soon as the tape head goes beyond the tape (represented by <code>Nothing</code> in the code below), it writes an ‘E’ there and goes to state 1. In this state, it will just move the tape head all the way back to the left until the start of the tape, at which point it will write an ‘S’ to the tape and go into state 2, which is the accepting state. It is easy to see that this machine terminates on all possible inputs.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A Turing machine accepting all input.</span>
<span class="ot">testMachine ::</span> <span class="dt">Machine</span>
testMachine <span class="fu">=</span>
  <span class="dt">Machine</span> { transition <span class="fu">=</span> t
          , startState <span class="fu">=</span> <span class="dv">0</span>
          , acceptState <span class="fu">=</span> <span class="dv">2</span>
          , rejectState <span class="fu">=</span> <span class="dv">3</span>} <span class="kw">where</span>

  t <span class="dv">0</span> (<span class="dt">Just</span> x) <span class="fu">=</span> (<span class="dv">0</span>,   x, <span class="dt">MoveRight</span>)
  t <span class="dv">0</span> <span class="dt">Nothing</span>  <span class="fu">=</span> (<span class="dv">1</span>, <span class="ch">'E'</span>, <span class="dt">MoveLeft</span>)
  t <span class="dv">1</span> (<span class="dt">Just</span> x) <span class="fu">=</span> (<span class="dv">1</span>,   x, <span class="dt">MoveLeft</span>)
  t <span class="dv">1</span> <span class="dt">Nothing</span>  <span class="fu">=</span> (<span class="dv">2</span>, <span class="ch">'S'</span>, <span class="dt">MoveRight</span>)

main <span class="fu">=</span> print <span class="fu">$</span> runMachine testMachine <span class="st">&quot;10011&quot;</span></code></pre>
<p>What is the output of running this?</p>
<pre><code>michi ~ $ runhaskell Turing.hs
10011
| q0

10011
 | q0

10011
  | q0

10011
   | q0

10011
    | q0

10011 
     | q0

10011E
    | q1

10011E
   | q1

10011E
  | q1

10011E
 | q1

10011E
| q1

 10011E
| q1

S10011E
 | q2</code></pre>
<p>In the output, we see the different configurations of the Turing machine for the input word “10011”. The ‘|’ signifies the current position of the tape head, and the “qn” signifies the current state. In the last configuration, we see that the Turing machine has reached state q2, and because q2 is the accepting state, we know that the Turing machine has accepted the input word.</p>
<p>I hope that this article has been instructive. Have fun playing with <a href="../media/2015-01-10-turinghaskell/Turing.hs">the code</a>, and if you want something more visual to get a feeling for Turing machines, I can warmly recommend you to look at <a href="http://pleasingfungus.com/Manufactoria/">Manufactoria</a>. It has certainly delayed the publication of this article by several hours. ;)</p>

        </div>
        <div id="footer">
            Post: (λ name domain. name@domain) "michael.faerber" "gedenkt.at"
        </div>
    </body>
</html>

<link rel="icon" type="image/png" href="../media/gedenkt_small.png">
<link rel="stylesheet" type="text/css" href="../css/default.css">
<link rel="stylesheet" type="text/css" href="../css/syntax.css">
