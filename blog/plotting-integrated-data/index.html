<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Plotting integrated data - gedenkt.at</title>

    <link rel="icon" type="image/png" href="../../media/gedenkt_small.png">
    <link rel="stylesheet" type="text/css" href="../../css/default.css">
    <link rel="stylesheet" type="text/css" href="../../css/syntax.css">
  </head>
  <body>
    <div id="header">
      <div id="logo">
        <a href="../../"><img src="../../media/gedenkt_small.png" /></a>
      </div>
      <div id="navigation">
        <a href="../../">Initium</a>
        <a href="../../erasmus.html">Erasmus</a>
        <a href="../../musica.html">Musica</a>
        <a href="../../blog.html">Blog</a>
      </div>
    </div>

    <div id="content">
      <h1>Plotting integrated data</h1>

      <img src="../../media/gedenkt.png" style="float: right; margin: 10px;" />

<div class="info">
    Geschrieben am 09. Mai 2016
    
</div>

<p>I recently created a graph that shows how much CPU time a number of processes took before they terminated. For this, I ran my processes with the <code>time</code> command, such as:</p>
<pre><code>/usr/bin/time -o command.time &lt;command&gt;</code></pre>
<p>This produces a file “command.time” like the following:</p>
<pre><code>7.91user 0.08system 0:08.00elapsed 99%CPU (0avgtext+0avgdata 168352maxresident)k
0inputs+8outputs (0major+21257minor)pagefaults 0swaps</code></pre>
<p>When we have several of such files, we might be interested in showing at which points in time every command terminated. For this, let us assume we have a directory with several “.time” files. Let us first filter out the unnecessary lines:</p>
<pre><code>cat *.time | grep &quot;elapsed&quot;</code></pre>
<p>That gives something like:</p>
<pre><code>3.22user 0.23system 0:03.47elapsed 99%CPU (0avgtext+0avgdata 908592maxresident)k
3.93user 0.44system 0:04.41elapsed 99%CPU (0avgtext+0avgdata 722864maxresident)k
0.87user 0.04system 0:00.92elapsed 99%CPU (0avgtext+0avgdata 86576maxresident)k
0.39user 0.06system 0:00.46elapsed 99%CPU (0avgtext+0avgdata 89088maxresident)k
[...]</code></pre>
<p>For the sake of this example, we are only interested in the user time, which roughly corresponds to the time the program was working itself, in contrast to the time it waited for the kernel to perform tasks. So let us <code>cut</code> away every but the first column:</p>
<pre><code>cat *.time | grep &quot;elapsed&quot; | cut -d &quot;u&quot; -f 1</code></pre>
<p>(The “-d” option specifies a delimiter, and the “-f” option specifies that only the first field before a delimiter should be output.)</p>
<p>The output of this is:</p>
<pre><code>3.22
3.93
0.87
0.39
[...]</code></pre>
<p>Now I want a graph that makes a tiny “jump” at every point in time given by the data above, thus integrating over all the data. For this task, I created a Haskell program “integrate.hs”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Category</span> ((&gt;&gt;&gt;))
<span class="kw">import </span><span class="dt">Data.List</span> (sort)

process <span class="fu">=</span>
  lines <span class="fu">&gt;&gt;&gt;</span>
  map read <span class="fu">&gt;&gt;&gt;</span>
  sort <span class="fu">&gt;&gt;&gt;</span>
  scanl (\ (_, y) x <span class="ot">-&gt;</span> (x, y<span class="fu">+</span><span class="dv">1</span>)) (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Double</span>, <span class="dv">0</span>) <span class="fu">&gt;&gt;&gt;</span>
  map (\ (x, y) <span class="ot">-&gt;</span> show x <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> show y)

main <span class="fu">=</span> getContents <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> process <span class="fu">&gt;&gt;=</span> mapM putStrLn</code></pre></div>
<p>Compile it with <code>ghc integrate.hs</code>, yielding an executable “integrate”. Now you can use <code>gnuplot</code> to see the final result:</p>
<pre><code>cat *.time | grep &quot;elapsed&quot; | cut -d &quot;u&quot; -f 1 | ./integrate &gt; integrated
gnuplot -e &quot;plot 'integrated'; pause -1&quot;</code></pre>
<p>To plot it to a PNG file:</p>
<pre><code>gnuplot -e &quot;set term png; set output 'gnuplot.png'; plot 'integrated'&quot;</code></pre>
<div class="figure">
<img src="../../media/2016-05-09-plotting-integrated-data/gnuplot.png" alt="Gnuplot result." />
<p class="caption">Gnuplot result.</p>
</div>
<p>If you want to display the resulting plot in LaTeX, you can use TikZ:</p>
<pre class="tex"><code>\documentclass[preview]{standalone}

\usepackage{pgfplots}
\pgfplotsset{compat=1.9}
\usepgfplotslibrary{units}

\begin{document}

\begin{tikzpicture}
\begin{axis}
[ legend pos=south east
, xlabel=Time
, x unit=s
, ylabel=Problems solved
, mark repeat={1000}
]
\addplot table {offline.integrated};
\addlegendentry{Offline};
\addplot table {training.integrated};
\addlegendentry{Training};
\end{axis}
\end{tikzpicture}

\end{document}</code></pre>
<p>To compile it:</p>
<pre><code>pdflatex tikz.tex
convert -density 150 tikz.pdf -quality 90 -trim tikz.png</code></pre>
<div class="figure">
<img src="../../media/2016-05-09-plotting-integrated-data/tikz.png" alt="TikZ result." />
<p class="caption">TikZ result.</p>
</div>
<p>Voilà ! Have fun creating your own integrated data plots!</p>

    </div>

    <div id="footer">
      Post: (λ name domain. name@domain) "michael.faerber" "gedenkt.at"
    </div>
  </body>
</html>

<script async type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
